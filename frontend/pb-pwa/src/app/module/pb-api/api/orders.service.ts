/**
 * Powerbot-Trading Api
 * # TERMS AND CONDITIONS The Powerbot Trading REST API provide B2B services for trading with the EPEX intraday market. By using the Powerbot Trading REST API , each user agrees to the terms and conditions of this licence: 1. The user will comply with the [EPEX Spot Market Rules](https://www.epexspot.com/en/extras/download-center/documentation) and will not endanger the EPEX system (M7) at any time with heavy load from trading algorithms. 2. The user is aware of the OTR limits by EPEX  # INTRODUCTION The Powerbot-Trading Api is a web-based software service enabling algorithmic trading on power exchanges such as EPEX, HUPX or BSP Southpool.  The service is straightforward to integrate in an existing software environment and provides a variety of programming interfaces for development of  individual trading algorithms and software tools. Besides enabling a fully automated intraday trading strategy,  PowerBot can be used to create support tools for traders providing relevant information and trading opportunities.  For furher details see http://powerbot-trading.com  In addition to this API guide, there is a [playground](https://playground.powerbot-trading.com) where you can try out the API calls directly from your web browser.  In order to access the playground, you will need an API key which you can request from Inercomp. Please contact us at helmut.spindler@inercomp.com    ## Endpoints The Powerbot Trading REST API is available at the following REST endpoints:  | Instance                | Base URL for REST Endpoints                     | |-------------------------|-------------------------------------------------| | Test                    | https://playground.powerbot-trading.com/api/v0  | | Staging, Production     | Provided on request                     |  Access to endpoints is secured via an API Key, which needs to be passed as an  \"api_key\" header in each request.     Notes on API Keys:  * API keys are specific to Test, Staging or Production.  * An API key is associated with a user account and needs to requested. Please contact us by email at helmut.spindler@inercomp.com to request an API key.  ## Errors The API uses standard HTTP status codes to indicate the success or failure of the API call. The body of the response will be in JSON format as follows:  ``` {   \"message\": \"... an error message ...\" } ```  ## Paging The API uses offset and limit parameters for paged operations. An X-Total-Count header is added to responses to indicate the total number of items in a paged response.     ## Cross-Origin Resource Sharing This API features Cross-Origin Resource Sharing (CORS) implemented in compliance with  [W3C spec](https://www.w3.org/TR/cors/). This allows cross-domain communication from the browser. All responses have a wildcard same-origin which makes them completely public and accessible to everyone, including any code on any site.  ## Additional code samples Additional information and code samples demonstrating the use of the API can be found at https://github.com/powerbot-trading/python-samples.
 *
 * OpenAPI spec version: 1.1.0
 *
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */
/* tslint:disable:no-unused-variable member-ordering */

import { Inject, Injectable, Optional }                      from '@angular/core';
import { HttpClient, HttpHeaders, HttpParams,
         HttpResponse, HttpEvent }                           from '@angular/common/http';
import { CustomHttpUrlEncodingCodec }                        from '../encoder';

import { Observable }                                        from 'rxjs/Observable';

import { InlineResponse20012 } from '../model/inlineResponse20012';
import { InlineResponse20013 } from '../model/inlineResponse20013';
import { InlineResponse2007 } from '../model/inlineResponse2007';
import { InlineResponseDefault } from '../model/inlineResponseDefault';
import { Modifications } from '../model/modifications';
import { Order } from '../model/order';
import { Order1 } from '../model/order1';
import { Orders } from '../model/orders';

import { BASE_PATH, COLLECTION_FORMATS }                     from '../variables';
import { Configuration }                                     from '../configuration';


@Injectable()
export class OrdersService {

    public defaultHeaders = new HttpHeaders();
    public configuration = new Configuration();

    constructor(protected httpClient: HttpClient, @Optional() configuration: Configuration) {
        if (configuration) {
            this.configuration = configuration;
        }
    }

    /**
     * @param consumes string[] mime-types
     * @return true: consumes contains 'multipart/form-data', false: otherwise
     */
    private canConsumeForm(consumes: string[]): boolean {
        const form = 'multipart/form-data';
        for (const consume of consumes) {
            if (form === consume) {
                return true;
            }
        }
        return false;
    }


    /**
     * Place new order
     * Allows you to place a new sell or bid order.
     * @param order
     * @param internalTrading set to true, internal trading will be performed before submitting the orders to EPEX.  set to false if you don&#39;t want internal trading don&#39;t set it if the default market option (internal_trading) should determine if internal trading should be performed
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public addOrder(order: Order, internalTrading?: boolean, observe?: 'body', reportProgress?: boolean): Observable<InlineResponse2007>;
    public addOrder(order: Order, internalTrading?: boolean, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<InlineResponse2007>>;
    public addOrder(order: Order, internalTrading?: boolean, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<InlineResponse2007>>;
    public addOrder(order: Order, internalTrading?: boolean, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (order === null || order === undefined) {
            throw new Error('Required parameter order was null or undefined when calling addOrder.');
        }

        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (internalTrading !== undefined && internalTrading !== null) {
            queryParameters = queryParameters.set('internal_trading', <any>internalTrading);
        }

        let headers = this.defaultHeaders;

        // authentication (api_key_security) required
        if (this.configuration.apiKeys["api_key"]) {
            headers = headers.set('api_key', this.configuration.apiKeys["api_key"]);
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

      return this.httpClient.post<InlineResponse2007>(`${this.configuration.basePath}/orders`,
            order,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Place a list of new orders
     * Allows you to place a new sell or bid orders. For each requested order one response is generated. In case of sucess, the order is returned otherwise an error message is returned.
     * @param order
     * @param execInstruction Defines the execution instruction for the whole list of orders:    * **VALID**: default. All orders must be valid, meaning they must past the order validation of the backend system (e.g. the price of the order must be in the price range of the product). If one order does not pass the validation, the full list of submitted orders is rejected.   * **LNKD**: Linked orders - the provided orders are linked together and should be executed all at once. This option can only be used, if all orders have the same product and the execution restriction FOK (Fill-or-Kill). In case one of the orders cannot be executed, the whole list is not executed. The Linked Orders feature is configurable and might be turned off by EPEX.
     * @param internalTrading set to true, internal matching will be performed before submitting the orders to EPEX.  set to false if you don&#39;t want internal matching don&#39;t set it if the default market option (internal_trading) should determine if internal matching should be performed
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public addOrders(order: Array<Order1>, execInstruction?: 'VALID' | 'LNKD', internalTrading?: boolean, observe?: 'body', reportProgress?: boolean): Observable<Array<InlineResponse2007>>;
    public addOrders(order: Array<Order1>, execInstruction?: 'VALID' | 'LNKD', internalTrading?: boolean, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<InlineResponse2007>>>;
    public addOrders(order: Array<Order1>, execInstruction?: 'VALID' | 'LNKD', internalTrading?: boolean, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<InlineResponse2007>>>;
    public addOrders(order: Array<Order1>, execInstruction?: 'VALID' | 'LNKD', internalTrading?: boolean, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (order === null || order === undefined) {
            throw new Error('Required parameter order was null or undefined when calling addOrders.');
        }

        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (execInstruction !== undefined && execInstruction !== null) {
            queryParameters = queryParameters.set('exec_instruction', <any>execInstruction);
        }
        if (internalTrading !== undefined && internalTrading !== null) {
            queryParameters = queryParameters.set('internal_trading', <any>internalTrading);
        }

        let headers = this.defaultHeaders;

        // authentication (api_key_security) required
        if (this.configuration.apiKeys["api_key"]) {
            headers = headers.set('api_key', this.configuration.apiKeys["api_key"]);
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

      return this.httpClient.post<Array<InlineResponse2007>>(`${this.configuration.basePath}/orders/list`,
            order,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Retrieves the public order book (sorted by delivery ascending)
     * Shows the public order book for the selected product containing the active bids/asks and the applicable signals
     * @param product The product (e.g. Intraday_Power_D) for which the orderbook should be retrieved
     * @param withBidOrAskOnly If set to true, the returned orderbook will contain only contracts which contain at least one active bid or ask
     * @param contractId limit the orderbook to a certain contract only
     * @param contractName limit the orderbook to a certain contract name only
     * @param deliveryStart limit the orderbook to those contracts with the given delivery start date
     * @param deliveryEnd limit the orderbook to those contracts with the given delivery end date
     * @param deliveryWithin limit the orderbook to those contracts having a delivery start/end date which starts before and ends after the given parameter
     * @param pastHours The number of hours to look behind in the orderbook. If this parameter is set, also historic closed contacts are contained in the orderbook
     * @param deliveryArea The delivery area of the orderbook; Mandatory unless in a multi-delivery-area environment, and a default delivery area is configured in the market options.
     * @param withDetails If set to true, details about contract and orderbook are returned.
     * @param limit Limits the number of returned order books
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getOrderBook(product: string, withBidOrAskOnly?: boolean, contractId?: number, contractName?: string, deliveryStart?: Date, deliveryEnd?: Date, deliveryWithin?: Date, pastHours?: number, deliveryArea?: string, withDetails?: boolean, limit?: number, observe?: 'body', reportProgress?: boolean): Observable<InlineResponse20013>;
    public getOrderBook(product: string, withBidOrAskOnly?: boolean, contractId?: number, contractName?: string, deliveryStart?: Date, deliveryEnd?: Date, deliveryWithin?: Date, pastHours?: number, deliveryArea?: string, withDetails?: boolean, limit?: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<InlineResponse20013>>;
    public getOrderBook(product: string, withBidOrAskOnly?: boolean, contractId?: number, contractName?: string, deliveryStart?: Date, deliveryEnd?: Date, deliveryWithin?: Date, pastHours?: number, deliveryArea?: string, withDetails?: boolean, limit?: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<InlineResponse20013>>;
    public getOrderBook(product: string, withBidOrAskOnly?: boolean, contractId?: number, contractName?: string, deliveryStart?: Date, deliveryEnd?: Date, deliveryWithin?: Date, pastHours?: number, deliveryArea?: string, withDetails?: boolean, limit?: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (product === null || product === undefined) {
            throw new Error('Required parameter product was null or undefined when calling getOrderBook.');
        }

        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (withBidOrAskOnly !== undefined && withBidOrAskOnly !== null) {
            queryParameters = queryParameters.set('with_bid_or_ask_only', <any>withBidOrAskOnly);
        }
        if (contractId !== undefined && contractId !== null) {
            queryParameters = queryParameters.set('contractId', <any>contractId);
        }
        if (contractName !== undefined && contractName !== null) {
            queryParameters = queryParameters.set('contractName', <any>contractName);
        }
        if (deliveryStart !== undefined && deliveryStart !== null) {
            queryParameters = queryParameters.set('delivery_start', <any>deliveryStart.toISOString());
        }
        if (deliveryEnd !== undefined && deliveryEnd !== null) {
            queryParameters = queryParameters.set('delivery_end', <any>deliveryEnd.toISOString());
        }
        if (deliveryWithin !== undefined && deliveryWithin !== null) {
            queryParameters = queryParameters.set('delivery_within', <any>deliveryWithin.toISOString());
        }
        if (pastHours !== undefined && pastHours !== null) {
            queryParameters = queryParameters.set('past_hours', <any>pastHours);
        }
        if (deliveryArea !== undefined && deliveryArea !== null) {
            queryParameters = queryParameters.set('delivery_area', <any>deliveryArea);
        }
        if (withDetails !== undefined && withDetails !== null) {
            queryParameters = queryParameters.set('with_details', <any>withDetails);
        }
        if (limit !== undefined && limit !== null) {
            queryParameters = queryParameters.set('limit', <any>limit);
        }

        let headers = this.defaultHeaders;

        // authentication (api_key_security) required
        if (this.configuration.apiKeys["api_key"]) {
            headers = headers.set('api_key', this.configuration.apiKeys["api_key"]);
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];

      return this.httpClient.get<InlineResponse20013>(`${this.configuration.basePath}/orderbook/${encodeURIComponent(String(product))}`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Retrieves the public order books (sorted by delivery ascending)
     * Shows the public order books for the requested products (or all available products)
     * @param product The list of products (e.g. Intraday_Power_D or Intraday_Power_D,XBID_Hour_Power) for which the orderbook(s) should be retrieved; leave blank if you want all available orderbooks
     * @param withBidOrAskOnly If set to true, the returned orderbook will contain only contracts which contain at least one active bid or ask
     * @param contractId limit the orderbook to a certain contract only
     * @param contractName limit the orderbook to a certain contract name only
     * @param deliveryStart limit the orderbook to those contracts with the given delivery start date
     * @param deliveryEnd limit the orderbook to those contracts with the given delivery end date
     * @param deliveryWithin limit the orderbook to those contracts having a delivery start/end date which starts before and ends after the given parameter
     * @param pastHours The number of hours to look behind in the orderbook. If this parameter is set, also historic closed contacts are contained in the orderbook
     * @param deliveryArea The delivery area of the orderbook
     * @param withDetails If set to true, details about contract and orderbook are returned.
     * @param limit Limits the number of returned order books
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getOrderBooks(product?: string, withBidOrAskOnly?: boolean, contractId?: number, contractName?: string, deliveryStart?: Date, deliveryEnd?: Date, deliveryWithin?: Date, pastHours?: number, deliveryArea?: string, withDetails?: boolean, limit?: number, observe?: 'body', reportProgress?: boolean): Observable<InlineResponse20012>;
    public getOrderBooks(product?: string, withBidOrAskOnly?: boolean, contractId?: number, contractName?: string, deliveryStart?: Date, deliveryEnd?: Date, deliveryWithin?: Date, pastHours?: number, deliveryArea?: string, withDetails?: boolean, limit?: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<InlineResponse20012>>;
    public getOrderBooks(product?: string, withBidOrAskOnly?: boolean, contractId?: number, contractName?: string, deliveryStart?: Date, deliveryEnd?: Date, deliveryWithin?: Date, pastHours?: number, deliveryArea?: string, withDetails?: boolean, limit?: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<InlineResponse20012>>;
    public getOrderBooks(product?: string, withBidOrAskOnly?: boolean, contractId?: number, contractName?: string, deliveryStart?: Date, deliveryEnd?: Date, deliveryWithin?: Date, pastHours?: number, deliveryArea?: string, withDetails?: boolean, limit?: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (product !== undefined && product !== null) {
            queryParameters = queryParameters.set('product', <any>product);
        }
        if (withBidOrAskOnly !== undefined && withBidOrAskOnly !== null) {
            queryParameters = queryParameters.set('with_bid_or_ask_only', <any>withBidOrAskOnly);
        }
        if (contractId !== undefined && contractId !== null) {
            queryParameters = queryParameters.set('contractId', <any>contractId);
        }
        if (contractName !== undefined && contractName !== null) {
            queryParameters = queryParameters.set('contractName', <any>contractName);
        }
        if (deliveryStart !== undefined && deliveryStart !== null) {
            queryParameters = queryParameters.set('delivery_start', <any>deliveryStart.toISOString());
        }
        if (deliveryEnd !== undefined && deliveryEnd !== null) {
            queryParameters = queryParameters.set('delivery_end', <any>deliveryEnd.toISOString());
        }
        if (deliveryWithin !== undefined && deliveryWithin !== null) {
            queryParameters = queryParameters.set('delivery_within', <any>deliveryWithin.toISOString());
        }
        if (pastHours !== undefined && pastHours !== null) {
            queryParameters = queryParameters.set('past_hours', <any>pastHours);
        }
        if (deliveryArea !== undefined && deliveryArea !== null) {
            queryParameters = queryParameters.set('delivery_area', <any>deliveryArea);
        }
        if (withDetails !== undefined && withDetails !== null) {
            queryParameters = queryParameters.set('with_details', <any>withDetails);
        }
        if (limit !== undefined && limit !== null) {
            queryParameters = queryParameters.set('limit', <any>limit);
        }

        let headers = this.defaultHeaders;

        // authentication (api_key_security) required
        if (this.configuration.apiKeys["api_key"]) {
            headers = headers.set('api_key', this.configuration.apiKeys["api_key"]);
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];

        return this.httpClient.get<InlineResponse20012>(`${this.configuration.basePath}/orderbooks`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * List of own orders
     *
     * @param offset Offset when loading a list of items
     * @param limit Limits the number of loaded items
     * @param contractId Show only those orders related to a specific contract
     * @param activeOnly Returns only those orders which are active
     * @param deliveryArea The delivery area
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getOwnOrders(offset?: number, limit?: number, contractId?: number, activeOnly?: boolean, deliveryArea?: string, observe?: 'body', reportProgress?: boolean): Observable<Array<InlineResponse2007>>;
    public getOwnOrders(offset?: number, limit?: number, contractId?: number, activeOnly?: boolean, deliveryArea?: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<InlineResponse2007>>>;
    public getOwnOrders(offset?: number, limit?: number, contractId?: number, activeOnly?: boolean, deliveryArea?: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<InlineResponse2007>>>;
    public getOwnOrders(offset?: number, limit?: number, contractId?: number, activeOnly?: boolean, deliveryArea?: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (offset !== undefined && offset !== null) {
            queryParameters = queryParameters.set('offset', <any>offset);
        }
        if (limit !== undefined && limit !== null) {
            queryParameters = queryParameters.set('limit', <any>limit);
        }
        if (contractId !== undefined && contractId !== null) {
            queryParameters = queryParameters.set('contract_id', <any>contractId);
        }
        if (activeOnly !== undefined && activeOnly !== null) {
            queryParameters = queryParameters.set('active_only', <any>activeOnly);
        }
        if (deliveryArea !== undefined && deliveryArea !== null) {
            queryParameters = queryParameters.set('delivery_area', <any>deliveryArea);
        }

        let headers = this.defaultHeaders;

        // authentication (api_key_security) required
        if (this.configuration.apiKeys["api_key"]) {
            headers = headers.set('api_key', this.configuration.apiKeys["api_key"]);
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];

        return this.httpClient.get<Array<InlineResponse2007>>(`${this.configuration.basePath}/orders`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Modifies an existing order
     * Changes, activates or deactivates an existing order
     * @param orderId the unique order_id. **Heads up!** After an order has been modified, it will change its&#39;s order_id!
     * @param modifications
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public modifyOrder(orderId: number, modifications?: Modifications, observe?: 'body', reportProgress?: boolean): Observable<Array<InlineResponse2007>>;
    public modifyOrder(orderId: number, modifications?: Modifications, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<InlineResponse2007>>>;
    public modifyOrder(orderId: number, modifications?: Modifications, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<InlineResponse2007>>>;
    public modifyOrder(orderId: number, modifications?: Modifications, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (orderId === null || orderId === undefined) {
            throw new Error('Required parameter orderId was null or undefined when calling modifyOrder.');
        }

        let headers = this.defaultHeaders;

        // authentication (api_key_security) required
        if (this.configuration.apiKeys["api_key"]) {
            headers = headers.set('api_key', this.configuration.apiKeys["api_key"]);
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.put<Array<InlineResponse2007>>(`${this.configuration.basePath}/order/${encodeURIComponent(String(orderId))}`,
            modifications,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Updates the status of all own orders at once
     *
     * @param orders
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public updateStatus(orders: Orders, observe?: 'body', reportProgress?: boolean): Observable<any>;
    public updateStatus(orders: Orders, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;
    public updateStatus(orders: Orders, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;
    public updateStatus(orders: Orders, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (orders === null || orders === undefined) {
            throw new Error('Required parameter orders was null or undefined when calling updateStatus.');
        }

        let headers = this.defaultHeaders;

        // authentication (api_key_security) required
        if (this.configuration.apiKeys["api_key"]) {
            headers = headers.set('api_key', this.configuration.apiKeys["api_key"]);
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.put<any>(`${this.configuration.basePath}/orders/status`,
            orders,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

}
