/**
 * Powerbot-Trading Api
 * # TERMS AND CONDITIONS The Powerbot Trading REST API provide B2B services for trading with the EPEX intraday market. By using the Powerbot Trading REST API , each user agrees to the terms and conditions of this licence: 1. The user will comply with the [EPEX Spot Market Rules](https://www.epexspot.com/en/extras/download-center/documentation) and will not endanger the EPEX system (M7) at any time with heavy load from trading algorithms. 2. The user is aware of the OTR limits by EPEX  # INTRODUCTION The Powerbot-Trading Api is a web-based software service enabling algorithmic trading on power exchanges such as EPEX, HUPX or BSP Southpool.  The service is straightforward to integrate in an existing software environment and provides a variety of programming interfaces for development of  individual trading algorithms and software tools. Besides enabling a fully automated intraday trading strategy,  PowerBot can be used to create support tools for traders providing relevant information and trading opportunities.  For furher details see http://powerbot-trading.com  In addition to this API guide, there is a [playground](https://playground.powerbot-trading.com) where you can try out the API calls directly from your web browser.  In order to access the playground, you will need an API key which you can request from Inercomp. Please contact us at helmut.spindler@inercomp.com    ## Endpoints The Powerbot Trading REST API is available at the following REST endpoints:  | Instance                | Base URL for REST Endpoints                     | |-------------------------|-------------------------------------------------| | Test                    | https://playground.powerbot-trading.com/api/v0  | | Staging, Production     | Provided on request                     |  Access to endpoints is secured via an API Key, which needs to be passed as an  \"api_key\" header in each request.     Notes on API Keys:  * API keys are specific to Test, Staging or Production.  * An API key is associated with a user account and needs to requested. Please contact us by email at helmut.spindler@inercomp.com to request an API key.  ## Errors The API uses standard HTTP status codes to indicate the success or failure of the API call. The body of the response will be in JSON format as follows:  ``` {   \"message\": \"... an error message ...\" } ```  ## Paging The API uses offset and limit parameters for paged operations. An X-Total-Count header is added to responses to indicate the total number of items in a paged response.     ## Cross-Origin Resource Sharing This API features Cross-Origin Resource Sharing (CORS) implemented in compliance with  [W3C spec](https://www.w3.org/TR/cors/). This allows cross-domain communication from the browser. All responses have a wildcard same-origin which makes them completely public and accessible to everyone, including any code on any site.  ## Additional code samples Additional information and code samples demonstrating the use of the API can be found at https://github.com/powerbot-trading/python-samples.
 *
 * OpenAPI spec version: 1.1.0
 * 
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */
/* tslint:disable:no-unused-variable member-ordering */

import { Inject, Injectable, Optional }                      from '@angular/core';
import { HttpClient, HttpHeaders, HttpParams,
         HttpResponse, HttpEvent }                           from '@angular/common/http';
import { CustomHttpUrlEncodingCodec }                        from '../encoder';

import { Observable }                                        from 'rxjs/Observable';

import { InlineResponse20010 } from '../model/inlineResponse20010';
import { InlineResponse20011 } from '../model/inlineResponse20011';
import { InlineResponse2008 } from '../model/inlineResponse2008';
import { InlineResponse2009 } from '../model/inlineResponse2009';
import { InlineResponseDefault } from '../model/inlineResponseDefault';

import { BASE_PATH, COLLECTION_FORMATS }                     from '../variables';
import { Configuration }                                     from '../configuration';


@Injectable()
export class ContractService {

    protected basePath = 'https://playground.powerbot-trading.com:443/api/v0';
    public defaultHeaders = new HttpHeaders();
    public configuration = new Configuration();

    constructor(protected httpClient: HttpClient, @Optional()@Inject(BASE_PATH) basePath: string, @Optional() configuration: Configuration) {
        if (basePath) {
            this.basePath = basePath;
        }
        if (configuration) {
            this.configuration = configuration;
            this.basePath = basePath || configuration.basePath || this.basePath;
        }
    }

    /**
     * @param consumes string[] mime-types
     * @return true: consumes contains 'multipart/form-data', false: otherwise
     */
    private canConsumeForm(consumes: string[]): boolean {
        const form = 'multipart/form-data';
        for (const consume of consumes) {
            if (form === consume) {
                return true;
            }
        }
        return false;
    }


    /**
     * Finding contracts
     * 
     * @param contractId 
     * @param deliveryStart 
     * @param deliveryEnd 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public findContracts(contractId?: number, deliveryStart?: Date, deliveryEnd?: Date, observe?: 'body', reportProgress?: boolean): Observable<Array<InlineResponse20011>>;
    public findContracts(contractId?: number, deliveryStart?: Date, deliveryEnd?: Date, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<InlineResponse20011>>>;
    public findContracts(contractId?: number, deliveryStart?: Date, deliveryEnd?: Date, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<InlineResponse20011>>>;
    public findContracts(contractId?: number, deliveryStart?: Date, deliveryEnd?: Date, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (contractId !== undefined && contractId !== null) {
            queryParameters = queryParameters.set('contract_id', <any>contractId);
        }
        if (deliveryStart !== undefined && deliveryStart !== null) {
            queryParameters = queryParameters.set('delivery_start', <any>deliveryStart.toISOString());
        }
        if (deliveryEnd !== undefined && deliveryEnd !== null) {
            queryParameters = queryParameters.set('delivery_end', <any>deliveryEnd.toISOString());
        }

        let headers = this.defaultHeaders;

        // authentication (api_key_security) required
        if (this.configuration.apiKeys["api_key"]) {
            headers = headers.set('api_key', this.configuration.apiKeys["api_key"]);
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];

        return this.httpClient.get<Array<InlineResponse20011>>(`${this.basePath}/contracts`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Retrieves the history of the contract
     * 
     * @param contractId The unique id of the contract
     * @param deliveryArea The delivery area
     * @param fromRevision Revisions start with 0, each change increments it by 1
     * @param withDetails If set to true, details about contract and trades are returned.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getContractHistory(contractId: number, deliveryArea?: string, fromRevision?: number, withDetails?: boolean, observe?: 'body', reportProgress?: boolean): Observable<Array<InlineResponse2008>>;
    public getContractHistory(contractId: number, deliveryArea?: string, fromRevision?: number, withDetails?: boolean, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<InlineResponse2008>>>;
    public getContractHistory(contractId: number, deliveryArea?: string, fromRevision?: number, withDetails?: boolean, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<InlineResponse2008>>>;
    public getContractHistory(contractId: number, deliveryArea?: string, fromRevision?: number, withDetails?: boolean, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (contractId === null || contractId === undefined) {
            throw new Error('Required parameter contractId was null or undefined when calling getContractHistory.');
        }

        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (deliveryArea !== undefined && deliveryArea !== null) {
            queryParameters = queryParameters.set('delivery_area', <any>deliveryArea);
        }
        if (fromRevision !== undefined && fromRevision !== null) {
            queryParameters = queryParameters.set('from_revision', <any>fromRevision);
        }
        if (withDetails !== undefined && withDetails !== null) {
            queryParameters = queryParameters.set('with_details', <any>withDetails);
        }

        let headers = this.defaultHeaders;

        // authentication (api_key_security) required
        if (this.configuration.apiKeys["api_key"]) {
            headers = headers.set('api_key', this.configuration.apiKeys["api_key"]);
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];

        return this.httpClient.get<Array<InlineResponse2008>>(`${this.basePath}/contract/${encodeURIComponent(String(contractId))}/history`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Retrieves the current bids and asks of the contract
     * 
     * @param contractId 
     * @param deliveryArea The delivery area
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getOrders(contractId: number, deliveryArea?: string, observe?: 'body', reportProgress?: boolean): Observable<InlineResponse20010>;
    public getOrders(contractId: number, deliveryArea?: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<InlineResponse20010>>;
    public getOrders(contractId: number, deliveryArea?: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<InlineResponse20010>>;
    public getOrders(contractId: number, deliveryArea?: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (contractId === null || contractId === undefined) {
            throw new Error('Required parameter contractId was null or undefined when calling getOrders.');
        }

        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (deliveryArea !== undefined && deliveryArea !== null) {
            queryParameters = queryParameters.set('delivery_area', <any>deliveryArea);
        }

        let headers = this.defaultHeaders;

        // authentication (api_key_security) required
        if (this.configuration.apiKeys["api_key"]) {
            headers = headers.set('api_key', this.configuration.apiKeys["api_key"]);
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];

        return this.httpClient.get<InlineResponse20010>(`${this.basePath}/contract/${encodeURIComponent(String(contractId))}/orders`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Retrieves the public trades for the contract
     * 
     * @param contractId 
     * @param offset Offset when loading a list of items
     * @param limit Limits the number of loaded items
     * @param deliveryArea The delivery area
     * @param fromApiTimestamp from timestamp is &#39;inclusive&#39; (i.e. &gt;&#x3D;)
     * @param toApiTimestamp to timestamp is &#39;exclusive&#39; (i.e. &lt;)
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public getPublicTrades(contractId: number, offset?: number, limit?: number, deliveryArea?: string, fromApiTimestamp?: Date, toApiTimestamp?: Date, observe?: 'body', reportProgress?: boolean): Observable<Array<InlineResponse2009>>;
    public getPublicTrades(contractId: number, offset?: number, limit?: number, deliveryArea?: string, fromApiTimestamp?: Date, toApiTimestamp?: Date, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<InlineResponse2009>>>;
    public getPublicTrades(contractId: number, offset?: number, limit?: number, deliveryArea?: string, fromApiTimestamp?: Date, toApiTimestamp?: Date, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<InlineResponse2009>>>;
    public getPublicTrades(contractId: number, offset?: number, limit?: number, deliveryArea?: string, fromApiTimestamp?: Date, toApiTimestamp?: Date, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {
        if (contractId === null || contractId === undefined) {
            throw new Error('Required parameter contractId was null or undefined when calling getPublicTrades.');
        }

        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (offset !== undefined && offset !== null) {
            queryParameters = queryParameters.set('offset', <any>offset);
        }
        if (limit !== undefined && limit !== null) {
            queryParameters = queryParameters.set('limit', <any>limit);
        }
        if (deliveryArea !== undefined && deliveryArea !== null) {
            queryParameters = queryParameters.set('delivery_area', <any>deliveryArea);
        }
        if (fromApiTimestamp !== undefined && fromApiTimestamp !== null) {
            queryParameters = queryParameters.set('from_api_timestamp', <any>fromApiTimestamp.toISOString());
        }
        if (toApiTimestamp !== undefined && toApiTimestamp !== null) {
            queryParameters = queryParameters.set('to_api_timestamp', <any>toApiTimestamp.toISOString());
        }

        let headers = this.defaultHeaders;

        // authentication (api_key_security) required
        if (this.configuration.apiKeys["api_key"]) {
            headers = headers.set('api_key', this.configuration.apiKeys["api_key"]);
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];

        return this.httpClient.get<Array<InlineResponse2009>>(`${this.basePath}/contract/${encodeURIComponent(String(contractId))}/publictrades`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

}
